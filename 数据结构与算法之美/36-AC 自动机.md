[toc]

## 36 | AC自动机：如何用多模式串匹配实现敏感词过滤功能？

![img](imgs/b48bf407fcd03efc4ff2d3bd488d3666.jpg)

1.  开篇题
    -   实现一个高性能的敏感词过滤系统

### 单模式串&多模式串

1.  **单模式串**匹配算法，是在**一个模式串**和**一个主串**之间进行匹配，也就是说，在一个主串中查找一个模式串。
    -   BF/RK/BM/KMP 算法
2.  **多模式串**匹配算法，就是在**多个模式串**和**一个主串**之间做匹配，也就是说，在一个主串中查找多个模式串。
    1.  多模式串匹配算法，只需要扫描**一遍**主串，就能在主串中一次性查找多个模式串是否存在
    2.  Trie 树

### AC 自动机（经典多模式串匹配算法）

1.  AC 自动机，实际上就是在 **Trie 树**之上，加了类似 KMP 的 **next** 数组，只不过此处的 next 数组是构建在树上罢了

2.  代码

    -   ```java
        
        public class AcNode {
          public char data; 
          public AcNode[] children = new AcNode[26]; // 字符集只包含a~z这26个字符
          public boolean isEndingChar = false; // 结尾字符为true
          public int length = -1; // 当isEndingChar=true时，记录模式串长度
          public AcNode fail; // 失败指针
          public AcNode(char data) {
            this.data = data;
          }
        }
        ```

3.  AC 自动机的构建，包含两个操作：

    -   将多个模式串**构建成 Trie 树**；
    -   在 Trie 树上**构建失败指针**（相当于 KMP 中的失效函数 next 数组）。
    
4.  如何在Trie 树之上**构建失败指针**？

    - 我们将 p 节点的失败指针指向那个**最长匹配后缀子串对应的模式串的前缀的最后一个节点**
    - ![img](imgs/582ec4651948b4cdc1e1b49235e4f8ca.jpg)

5.  如何寻找**p的子节点的失败指针**呢？

    - 如果**找到了**节点 q 的一个子节点 qc，对应的字符跟节点 pc 对应的字符**相同**，则将节点 pc 的失败指针指向节点 qc。

    - ![img](imgs/da685b7ac5f7dc41b2db6cf5d9a35a1f.jpg)
    - 如果节点 q 中**没有**子节点的字符等于节点 pc 包含的字符，则令 q=q->fail，继续上面的查找，直到 q 是 **root 为止**，如果还没有找到相同字符的子节点，就让节点 pc 的失败指针**指向 root**。
    - ![img](imgs/91123d8c38a050d32ca730a93c7aa061.jpg)

6.  代码实现

    - ```java
    	
    	public void buildFailurePointer() {
    	  Queue<AcNode> queue = new LinkedList<>();
    	  root.fail = null;
    	  queue.add(root);
    	  while (!queue.isEmpty()) {
    	    AcNode p = queue.remove();
    	    for (int i = 0; i < 26; ++i) {
    	      AcNode pc = p.children[i];
    	      if (pc == null) continue;
    	      if (p == root) {
    	        pc.fail = root;
    	      } else {
    	        AcNode q = p.fail;
    	        while (q != null) {
    	          AcNode qc = q.children[pc.data - 'a'];
    	          if (qc != null) {
    	            pc.fail = qc;
    	            break;
    	          }
    	          q = q.fail;
    	        }
    	        if (q == null) {
    	          pc.fail = root;
    	        }
    	      }
    	      queue.add(pc);
    	    }
    	  }
    	}
    	```

7.  如何在 AC 自动机上匹配主串？

    - 如果 p 指向的节点**有**一个等于 b[i] 的子节点 x，我们就更新 p 指向 x，这个时候我们需要通过失败指针，**检测一系列失败指针为结尾的路径是否是模式串**。这一句不好理解，你可以结合代码看。处理完之后，我们将 i 加一，继续这两个过程；
    - 如果 p 指向的节点**没有**等于 b[i]的子节点，那失败指针就派上用场了，我们让 **p=p->fail**，然后继续这 2 个过程。

8.  代码实现

    - ```java
    	
    	public void match(char[] text) { // text是主串
    	  int n = text.length;
    	  AcNode p = root;
    	  for (int i = 0; i < n; ++i) {
    	    int idx = text[i] - 'a';
    	    while (p.children[idx] == null && p != root) {
    	      p = p.fail; // 失败指针发挥作用的地方
    	    }
    	    p = p.children[idx];
    	    if (p == null) p = root; // 如果没有匹配的，从root开始重新匹配
    	    AcNode tmp = p;
    	    while (tmp != root) { // 打印出可以匹配的模式串
    	      if (tmp.isEndingChar == true) {
    	        int pos = i-tmp.length+1;
    	        System.out.println("匹配起始下标" + pos + "; 长度" + tmp.length);
    	      }
    	      tmp = tmp.fail;
    	    }
    	  }
    	}
    	```

    - 

