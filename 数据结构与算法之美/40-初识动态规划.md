[TOC]

## 40 | 初识动态规划：如何巧妙解决“双十一”购物时凑单问题？

1.  开篇题
	- "双十一"购物节凑单问题（满 200 减 50）
	- **让选出来的商品价值总和,最大程度地接近满减条件（200 元）**，这样就可以极大限度的“薅羊毛”。

### 学习路线

1.  动态规划比较适合用来**求解最优问题**，如最大值、最小值等等。
2.  它可以非常显著地降低时间复杂度，提高代码效率。
3.  学习路线
    1.  **初识动态规划**
        -   通过两个非常经典的动态规划问题模型，向你展示我们为什么需要动态规划，以及动态规划解题方法是如何演化出来的。
    2.  **动态规划理论**
        -   总结动态规划适合解决的问题特征，以及动态规划解题思路。
        -   我们还会将贪心、分治、回溯、动态规划这四种算法思想放在一起，对比它们各自的特点及适用的场景。
    3.  **动态规划实战**
        -   应用动态规划的理论知识，实战解决三个非常经典的动态规划问题，加深理论理解。

### 0-1 背包问题

1.  需求

    -   对于一组**不同重量、不可分割**的物品，我们需要选择一些装入背包，在满足背包最大重量限制的前提下，背包中物品总重量的最大值是多少呢？
    -   假设，我们背包最大承载重量是 9。 我们有 5 个不同的物品，每个物品重量分别是 2，2，4，6，3。

2.  回溯算法代码实现

    -   ```java
        // 回溯算法实现。注意：我把输入的变量都定义成了成员变量。
        private int maxW = Integer.MIN_VALUE; // 结果放到 maxW 中
        private int[] weight = {2，2，4，6，3};  // 物品重量
        private int n = 5; // 物品个数
        private int w = 9; // 背包承受的最大重量
        public void f(int i, int cw) { // 调用 f(0, 0)
          if (cw == w || i == n) { // cw==w 表示装满了，i==n 表示物品都考察完了
            if (cw > maxW) maxW = cw;
            return;
          }
          f(i+1, cw); // 选择不装第 i 个物品
          if (cw + weight[i] <= w) {
            f(i+1,cw + weight[i]); // 选择装第 i 个物品
          }
        }
        
        ```

3.  用**递归树**求解图

    -   ![img](imgs/42ca6cec4ad034fc3e5c0605fbacecea-0913243.jpg)

4.  代码实现（备忘录优化）

    -   ```java
        private int maxW = Integer.MIN_VALUE; // 结果放到 maxW 中
        private int[] weight = {2，2，4，6，3};  // 物品重量
        private int n = 5; // 物品个数
        private int w = 9; // 背包承受的最大重量
        private boolean[][] mem = new boolean[5][10]; // 备忘录，默认值 false
        public void f(int i, int cw) { // 调用 f(0, 0)
          if (cw == w || i == n) { // cw==w 表示装满了，i==n 表示物品都考察完了
            if (cw > maxW) maxW = cw;
            return;
          }
          if (mem[i][cw]) return; // 重复状态
          mem[i][cw] = true; // 记录 (i, cw) 这个状态
          f(i+1, cw); // 选择不装第 i 个物品
          if (cw + weight[i] <= w) {
            f(i+1,cw + weight[i]); // 选择装第 i 个物品
          }
        }
        
        ```


5.  动态规划求解思路

    -   我们把整个求解过程分为 n 个阶段，每个阶段会决策一个物品是否放到背包中。
    -   我们把每一层重复的状态（节点）合并，只记录不同的状态，然后基于上一层的状态集合，来推导下一层的状态集合。
    -   二维数组 `states[n][w+1]`，来记录每层达到的不同状态。

        -   ![img](imgs/aaf51df520ea6b8056f4e62aed81a5b5-0913232.jpg)

    -   代码实现如下

        -   ```java 
            weight: 物品重量，n: 物品个数，w: 背包可承载重量
            public int knapsack(int[] weight, int n, int w) {
              boolean[][] states = new boolean[n][w+1]; // 默认值 false
              states[0][0] = true;  // 第一行的数据要特殊处理，可以利用哨兵优化
              if (weight[0] <= w) {
                states[0][weight[0]] = true;
              }
              for (int i = 1; i < n; ++i) { // 动态规划状态转移
                for (int j = 0; j <= w; ++j) {// 不把第 i 个物品放入背包
                  if (states[i-1][j] == true) states[i][j] = states[i-1][j];
                }
                for (int j = 0; j <= w-weight[i]; ++j) {// 把第 i 个物品放入背包
                  if (states[i-1][j]==true) states[i][j+weight[i]] = true;
                }
              }
              for (int i = w; i >= 0; --i) { // 输出结果
                if (states[n-1][i] == true) return i;
              }
              return 0;
            }
            
            ```

6.  时间复杂度
    -    `O(n*w)` 
    
7.  代码优化（使用一维数组，降低空间消耗）

    -   动态规划状态转移的过程，都可以基于这个数组来操作。

    -   ```java
        public static int knapsack2(int[] items, int n, int w) {
          boolean[] states = new boolean[w+1]; // 默认值 false
          states[0] = true;  // 第一行的数据要特殊处理，可以利用哨兵优化
          if (items[0] <= w) {
            states[items[0]] = true;
          }
          for (int i = 1; i < n; ++i) { // 动态规划
            for (int j = w-items[i]; j >= 0; --j) {// 把第 i 个物品放入背包
              if (states[j]==true) states[j+items[i]] = true;
            }
          }
          for (int i = w; i >= 0; --i) { // 输出结果
            if (states[i] == true) return i;
          }
          return 0;
        }
        ```


