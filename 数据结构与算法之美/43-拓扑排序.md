[TOC]

## 43 | 拓扑排序：如何确定代码源文件的编译依赖关系？

1. 开篇题
	- 编译器是如何通过源文件两两之间的局部依赖关系，确定一个全局的编译顺序呢？
	- ![img](imgs/5247b6639e98419a1963cecd8f12713b-2419047.jpg)
### 算法解析

1. 代码实现

    - 拓扑排序本身就是基于**有向无环图**的一个算法。

    - ```java
        public class Graph {
          private int v; // 顶点的个数
          private LinkedList<Integer> adj[]; // 邻接表
        
          public Graph(int v) {
            this.v = v;
            adj = new LinkedList[v];
            for (int i=0; i<v; ++i) {
              adj[i] = new LinkedList<>();
            }
          }
        
          public void addEdge(int s, int t) { // s 先于 t，边 s->t
            adj[s].add(t);
          }
        }
        
        ```

#### Kahn 算法

1. 思想

    - **贪心算法的思想**。

2. 实现思路：

    - 我们先从图中，找出一个入度为 0 的顶点，将其输出到拓扑排序的结果序列中，并且把这个顶点从图中删除（也就是把这个顶点可达到的顶点的入度都减 1）。
    - 我们循环执行上面的过程，直到所有的顶点都被输出。
    - 最后输出的序列，就是满足局部依赖关系的拓扑排序。

3. 代码实现：

    - ```java
        public void topoSortByKahn() {
          int[] inDegree = new int[v]; // 统计每个顶点的入度
          for (int i = 0; i < v; ++i) {
            for (int j = 0; j < adj[i].size(); ++j) {
              int w = adj[i].get(j); // i->w
              inDegree[w]++;
            }
          }
          LinkedList<Integer> queue = new LinkedList<>();
          for (int i = 0; i < v; ++i) {
            if (inDegree[i] == 0) queue.add(i);
          }
          while (!queue.isEmpty()) {
            int i = queue.remove();
            System.out.print("->" + i);
            for (int j = 0; j < adj[i].size(); ++j) {
              int k = adj[i].get(j);
              inDegree[k]--;
              if (inDegree[k] == 0) queue.add(k);
            }
          }
        }
        
        ```

    - 

#### DFS 算法

1. 实现思路

    - **深度优先遍历**

2. 代码实现

    - ```java
        public void topoSortByDFS() {
          // 先构建逆邻接表，边 s->t 表示，s 依赖于 t，t 先于 s
          LinkedList<Integer> inverseAdj[] = new LinkedList[v];
          for (int i = 0; i < v; ++i) { // 申请空间
            inverseAdj[i] = new LinkedList<>();
          }
          for (int i = 0; i < v; ++i) { // 通过邻接表生成逆邻接表
            for (int j = 0; j < adj[i].size(); ++j) {
              int w = adj[i].get(j); // i->w
              inverseAdj[w].add(i); // w->i
            }
          }
          boolean[] visited = new boolean[v];
          for (int i = 0; i < v; ++i) { // 深度优先遍历图
            if (visited[i] == false) {
              visited[i] = true;
              dfs(i, inverseAdj, visited);
            }
          }
        }
        
        private void dfs(
            int vertex, LinkedList<Integer> inverseAdj[], boolean[] visited) {
          for (int i = 0; i < inverseAdj[vertex].size(); ++i) {
            int w = inverseAdj[vertex].get(i);
            if (visited[w] == true) continue;
            visited[w] = true;
            dfs(w, inverseAdj, visited);
          } // 先把 vertex 这个顶点可达的所有顶点都打印出来之后，再打印它自己
          System.out.print("->" + vertex);
        }
        
        ```

3. 关键部分：

    1. **通过邻接表构造逆邻接表**。
    2. **递归处理每个顶点**（核心）

#### 时间复杂度分析

1. Kahn: `O(V+E)` (V 表示顶点个数，E 表示边的个数)
2. DFS: `O(V+E)`