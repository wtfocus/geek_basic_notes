[toc]

## 55 | 算法实战（四）：剖析微服务接口鉴权限流背后的数据结构和算法

1. 开篇题
	- 今天，我们一起来体会鉴权和限流这两个功能背后的数据结构与算法

### 鉴权

1. 背景

	- ![img](imgs/1a574c209ab80e2dcdc9a52479d4f73d.jpg)

2. 准备

	- 先设置应用对接口的访问权限规则

		> 当某个应用访问其中一个接口的时候，我们就可以拿应用的请求 URL，在规则中进行匹配。如果匹配成功，就说明允许访问；
		>
		> 如果没有可以匹配的规则，那就说明这个应用没有这个接口的访问权限，我们就拒绝服务。

3. 细化为三个更加详细的需求

	- 如何实现精确匹配规则？
	- 如何实现前缀匹配规则？
	- 如何实现模糊匹配规则？

4. 精确匹配

	1. 只有当请求 URL 跟规则中配置的某个接口**精确匹配**时，这个请求才会被接受、处理。
		- ![img](imgs/19355363fa47c116edfd7d2ea57af4d1.jpg)

	2. 字符串匹配算法（比如 KMP、BM、BF 等）
	3. 规则不会经常变动，当要查找某个 URL 能否匹配其中某条规则的时候，我们可以采用**二分查找**算法，在有序数组中进行匹配。

5. 前缀匹配

	1. 只要某条规则可以匹配请求 URL 的**前缀**，我们就说这条规则能够跟这个请求 URL 匹配。
		- ![img](imgs/662c4ffb278fedf842f0dffa465673fe.jpg)
	2. 使用**Trie 树**这种数据结构
		- ![img](imgs/691d7f056fe48b8598f6f86568212db9.jpg)
	3. 利用**二分查找**算法，决定从一个节点应该跳到哪一个子节点。

6. 模糊匹配

	1. 规则中包含**通配符**。只要用户请求 URL 可以跟某条规则**模糊**匹配，我们就说这条规则适用于这个请求。

		- ![img](imgs/f756e2fef50776442be41e48d7aa5532.jpg)

	2. 我们可以把**不包含通配符**的规则和**包含通配符**的规则分开处理。

		- 把**不包含通配符**的规则，组织成有序数组或者 Trie 树

		- 把剩下的是少数**包含通配符**的规则，我们只要把它们简单存储在一个**数组**中就可以了

		- 处理流程

			> 当接收到一个请求 URL 之后，我们可以先在不包含通配符的有序数组或者 Trie 树中查找。
			>
			> 如果能够匹配，就不需要继续在通配符规则中匹配了；
			>
			> 如果不能匹配，就继续在通配符规则中查找匹配。

### 限流

1. 今天主要针对限制所有接口总的访问频率这样一个限流需求来讲解。那如何实现精准限流呢？

2. 固定时间窗口限流算法。

	- 流程图

		- ![img](imgs/cd1343d3f0f09c9eba7fb6387f01b63a.jpg)

	- 流程分解

		> 首先我们需要选定一个**时间起点**，之后每当有接口请求到来，我们就将计数器**加一**。
		>
		> 如果在当前时间窗口内，根据限流规则（比如每秒钟最大允许 100 次访问请求），出现累加访问次数**超过**限流值的情况时，我们就**拒绝**后续的访问请求。
		>
		> 当进入下一个时间窗口之后，计数器就**清零**重新计数。

3. 滑动时间窗口限流算法。

	- 流程图

		- ![img](imgs/748a2b39a068563d48837677016b8c79.jpg)

	- 流程分解

		> 我们假设限流的规则是，在任意 1s 内，接口的请求次数都不能大于 K 次。
		>
		> 我们就维护一个大小为 **K+1** 的循环队列，用来记录 1s 内到来的请求。注意，这里循环队列的大小等于**限流次数加一**，因为循环队列存储数据时会浪费一个存储单元。
		>
		> 当有新的请求到来时，我们将与这个新请求的时间间隔**超过** 1s 的请求，从队列中**删除**。然后，我们再来看循环队列中是否有空闲位置。
		>
		> 如果**有**，则把新请求**存储**在队列尾部（tail 指针所指的位置）；
		>
		> 如果**没有**，则说明这 1 秒内的请求次数已经超过了限流值 K，所以这个请求被**拒绝**服务。

