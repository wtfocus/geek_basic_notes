[TOC]

## 27 | 递归树： 如何借助树来求解递归算法的时间复杂度？

![img](https://static001.geekbang.org/resource/image/2f/6d/2fde598f081f84187695fbf1937c446d.jpg)

1.　开篇题

	- 借助递归树来**分析递归算法的时间复杂度**。

### 递归树与时间复杂度分析

1. 递归树 -- 斐波那契数列

    - ![img](imgs/1d9648b7f43e430473d76d24803159a3-6044548.jpg)

2. 如何用递归树来求解时间复杂度

    - ![img](https://static001.geekbang.org/resource/image/c6/d0/c66bfc3d02d3b7b8f64c208bf4c948d0.jpg)
    - 从图中看出，**每一层的归并操作消耗的时间总和是一样的**。
    - 每一层归并操作消耗的时间记作 n。高度记作 h。那么总的时间复杂度 **`O(n*h)`。**
    - 可以看出，归并排序递归树是一棵满二叉树。**满二叉树的高度大约是 $log_2n$。**所以归并排序递归实现的时间复杂度是 **`O(nlogn)`。**

### 实战一：分析快速排序的时间复杂度

1.　**理想情况下**
    - 每一层分区操作所遍历的数据个数之和是 n，递归树高度设为 h，总时间复杂度就是 `O(n*h)`
2.　极端情况下，两个分区比例为　`n:9n`

    -  递归树分析图
        - ![img](imgs/44972a3531dae0b7a0ccc935bc13f243-6044777.jpg)
        - 
-  递归树中**最短**的一个路径每次都乘以 1/10，**最长**的一个路径每次都乘以 9/10。
    -  通过计算，我们可以得到，从根节点到叶子节点的**最短路径**是 log<sub>10</sub>n，**最长路径**是 log<sub>10/9</sub>n。
       - ![img](imgs/7cea8607f0d92a901f3152341830d6ed-6390118.jpg)
    -  遍历数据的个数总和就介于  nlog<sub>10</sub>n 和 nlog<sub>10/9</sub>n 之间。
    -  根据复杂度大 O 表示法，对数复杂度的底数不管是多少，我们统一写成 logn。
    -  所以，**当分区大小比例是 `1:9`　时，快速排序的时间复杂度仍然是 O(nlogn)。**
3.  小结
    -   只要 k 的值不随 n 变化，是一个事先确定的常量，那快排的时间复杂度就是 `O(nlogn)`。

### 实战二：分析斐波那契数列的时间复杂度

1.  斐波那契数列：

    -   ```C
        int f(int n) {
          if (n == 1) return 1;
          if (n == 2) return 2;
          return f(n-1) + f(n-2);
        }
        
        ```

 2.  递归树分析图

    -   ![img](imgs/9ccbce1a70c7e2def52701dcf176a4ce-6045321.jpg)

 3.  这棵树的高度是多少呢？

    -   `f(n)` 分解为 `f(n-1)` 和 `f(n-2)`，每次数据规模都是 -1或 -2，叶子节点的数据规模是 1 或 2。
    -   如果每次都是 -1，那**最长路径**大约是 n。如果每次都是 -2，那**最短路径**大约是 n/2。

4.  时间复杂度分析

	- 每次分解之后的合并操作只需要一次加法运算，我们把这次加法运算的时间消耗记作 1。
	- 从上往下，第一层的总时间消耗是 1，第二层的总时间消耗是 2，第三层的总时间消耗就是 2<sup>2</sup>。依次类推，**第 k 层的时间消耗就是 2<sup>k-1</sup>**。
	- 那整个算法的总的时间消耗就是每一层时间消耗之和。

-   **如果路径长度都为 n，那这个总和就是 2<sup>n</sup> - 1。**
-   ![img](https://static001.geekbang.org/resource/image/86/1f/86d301fc5fa3088383fa5b45f01e4d1f.jpg)
    
-   **如果路径长度都是 n/2，那整个算法的总的时间消耗就是 2<sup>n/2</sup> - 1。**

    -   ![img](https://static001.geekbang.org/resource/image/55/d4/55fcb1570dfa09e457cdb93ba58777d4.jpg)

-   小结

    -   所以，**这个算法的时间复杂度就介于 O(2<sup>n</sup>) 和 O(<sup>n/2</sup>) 之间。**
    -   虽然这样得到的结果还不够精确，只是一个范围，但是，我们基本上知道了上面算法的时间复杂度是指数级的，非常高。

### 实战三：分析全排列的时间复杂度

-   我们再来看个稍微复杂的。

    -   “如何把 n 个数据的所有排列都找出来”，这就是**全排列**的问题。

-   例：

    -   如 1，2，3 这样 3 个数据，有下面几种不同的排列：

    -   ```
        1, 2, 3
        1, 3, 2
        2, 1, 3
        2, 3, 1
        3, 1, 2
        3, 2, 1
        ```

-   如何编程打印一组数据的所有排列呢？这里可以用**递归**来实现。

    -   如果我们确定了最后一位数据，那就变成了求解剩下 n-1 个数据的排列问题。而最后一位数据可以是 n 个数据中的任意一个，因此它的取值就有 n 种情况。所以，“n 个数据的排列”问题，就可以分解成 n 个 “n-1 个数据的排列”的子问题。

    -   递推公式

        -   ```
            假设数组中存储的是 1，2， 3...n。
                    
            f(1,2,...n) = {最后一位是 1, f(n-1)} + {最后一位是 2, f(n-1)} +...+{最后一位是 n, f(n-1)}。
            
            ```

    -   递推公式改写成代码

        -   ```java
            // 调用方式：
            // int[]a = a={1, 2, 3, 4}; printPermutations(a, 4, 4);
            // k 表示要处理的子数组的数据个数
            public void printPermutations(int[] data, int n, int k) {
              if (k == 1) {
                for (int i = 0; i < n; ++i) {
                  System.out.print(data[i] + " ");
                }
                System.out.println();
              }
            
              for (int i = 0; i < k; ++i) {
                int tmp = data[i];
                data[i] = data[k-1];
                data[k-1] = tmp;
            
                printPermutations(data, n, k - 1);
            
                tmp = data[i];
                data[i] = data[k-1];
                data[k-1] = tmp;
              }
            }
            
            ```

-   借助递归树，轻松分析出这个代码的时间复杂度。

    -   现在的递归树已经不是标准的二叉树了。
    -   ![img](https://static001.geekbang.org/resource/image/82/9b/82f40bed489cf29b14192b44decf059b.jpg)
    -   第一层分解有 n 次交换操作，
    -   第二层有 n 个节点，每个节点分解需要 n - 1 次交换，所以第二层总的交换次数是 n * (n-1)。
    -   第三层有 n * (n-1)个节点，每个节点分解需要 n - 2 次交换，所以第三层总的交换次数是 n * (n-1) * (n-2)
    -   ……
    -   以此类推，第 k 层总的交换次数就是 n * (n-1) * (n-2) * ... * (n-k+1)。最后一层的交换次数就是 n * (n-1) * (n-2) * ... * 2 * 1。每一层的交换次数之和就是总的交换次数。

-   小结

    -   我们看最后一个数， n * (n-1) * (n-2) * ... * 2 * 1 等于 n!，而前面的 n-1 个数都小于最后一个数，所以，总和肯定小于 n * n!，也就是说全排列的递归算法的时间复杂度大于 O(n!)，小于 O(n*n!)，虽然，我们没法知道非常精确的时间复杂度，但是，这样一个范围已经让我们知道，全排列的时间复杂度是非常高的。
    -   这里稍微说下，掌握分析的方法很重要，思路是重点，不要纠结于精确的时间复杂度到底是多少。

### 内容小结

-   今天，我们用递归树分析了递归代码的时间复杂度。加上我们在排序那一节讲到的递归公式时间复杂度方法，我们现在已经学习了两种递归代码的时间复杂度分析方法了。
-   有些代码比较适合用递推公式来分析，如，归并排序的时间复杂度、快速排序的最好情况时间复杂度。
-   有些代码比较适合用递归树来分析，如，快速排序的平均时间复杂度。
-   而有些可能两个都不怎么适合使用，如，二叉树的递归前中后序遍历。
-   在我们平时工作学习中，要多实战、多分析、只有这样，面对任何分析的时间复杂度分析，你才能做到游刃有余，毫不畏惧。

### 课后思考

1.  1 个细胞的生命周期是 3 小时间，1 个小时分裂一次。求 n 小时后，容器内有多少个细胞？请你用已经学过的递归时间复杂度的分析方法，分析一下这个递归问题的时间复杂度。

