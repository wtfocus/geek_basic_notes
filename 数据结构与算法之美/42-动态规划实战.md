[toc]

## 42 | 动态规划实战：如何实现搜索引擎中的拼写纠错功能？

### 如何量化两个字符串的相似度？

1. **编辑距离（Edit Distance）**

	- 将一个字符串转化成另一个字符串，需要的**最少编辑操作次数**（比如增加一个字符、删除一个字符、替换一个字符）
	- 编辑距离越大，说明两个字符串的相似程度越小；
	- 编辑距离就越小，说明两个字符串的相似程度越大。
	- 对于两个完全相同的字符串来说，编辑距离就是 0。

2. 多种计算方式

	- **莱文斯坦距离**（Levenshtein distance）

		> 允许增加、删除、替换字符这三个编辑操作
		>
		> 表示两个字符串**差异**的大小

	- **最长公共子串长度**（Longest common substring length）

		> 允许增加、删除字符这两个编辑操作
		>
		> 表示两个字符串**相似**程度的大小。

3. 计算方式图解

	- ![img](imgs/f0e72008ce8451609abed7e368ac420f.jpg)

### 莱文斯坦距离

1. 解析

	- 这个问题是求把一个字符串变成另一个字符串，需要的最少编辑次数。

2. 状态转移过程

	- 状态 (i, j) 可能从 (i-1, j)，(i, j-1)，(i-1, j-1) 三个状态中的任意一个转移过来。
	- ![img](imgs/11ffcba9b3c722c5487de7df5a0d6c89.jpg)

3. 状态转移方程

	- ```
		
		如果：a[i]!=b[j]，那么：min_edist(i, j)就等于：
		min(min_edist(i-1,j)+1, min_edist(i,j-1)+1, min_edist(i-1,j-1)+1)
		
		如果：a[i]==b[j]，那么：min_edist(i, j)就等于：
		min(min_edist(i-1,j)+1, min_edist(i,j-1)+1，min_edist(i-1,j-1))
		
		其中，min表示求三数中的最小值。     
		```

4. 状态表

	- ![img](imgs/ab44eb53fad2601c19f73604747d652d.jpg)

5. 代码实现

	- ```java
		
		public int lwstDP(char[] a, int n, char[] b, int m) {
		  int[][] minDist = new int[n][m];
		  for (int j = 0; j < m; ++j) { // 初始化第0行:a[0..0]与b[0..j]的编辑距离
		    if (a[0] == b[j]) minDist[0][j] = j;
		    else if (j != 0) minDist[0][j] = minDist[0][j-1]+1;
		    else minDist[0][j] = 1;
		  }
		  for (int i = 0; i < n; ++i) { // 初始化第0列:a[0..i]与b[0..0]的编辑距离
		    if (a[i] == b[0]) minDist[i][0] = i;
		    else if (i != 0) minDist[i][0] = minDist[i-1][0]+1;
		    else minDist[i][0] = 1;
		  }
		  for (int i = 1; i < n; ++i) { // 按行填表
		    for (int j = 1; j < m; ++j) {
		      if (a[i] == b[j]) minDist[i][j] = min(
		          minDist[i-1][j]+1, minDist[i][j-1]+1, minDist[i-1][j-1]);
		      else minDist[i][j] = min(
		          minDist[i-1][j]+1, minDist[i][j-1]+1, minDist[i-1][j-1]+1);
		    }
		  }
		  return minDist[n-1][m-1];
		}
		
		private int min(int x, int y, int z) {
		  int minv = Integer.MAX_VALUE;
		  if (x < minv) minv = x;
		  if (y < minv) minv = y;
		  if (z < minv) minv = z;
		  return minv;
		}
		```

	- 

### 最长公共子串

1. 解析

	- 它表征的也是两个字符串之间的相似程度。

2. 状态转移方程

	- ```
		
		如果：a[i]==b[j]，那么：max_lcs(i, j)就等于：
		max(max_lcs(i-1,j-1)+1, max_lcs(i-1, j), max_lcs(i, j-1))；
		
		如果：a[i]!=b[j]，那么：max_lcs(i, j)就等于：
		max(max_lcs(i-1,j-1), max_lcs(i-1, j), max_lcs(i, j-1))；
		
		其中max表示求三数中的最大值。
		```

3. 代码实现

	- ```java
		
		public int lcs(char[] a, int n, char[] b, int m) {
		  int[][] maxlcs = new int[n][m];
		  for (int j = 0; j < m; ++j) {//初始化第0行：a[0..0]与b[0..j]的maxlcs
		    if (a[0] == b[j]) maxlcs[0][j] = 1;
		    else if (j != 0) maxlcs[0][j] = maxlcs[0][j-1];
		    else maxlcs[0][j] = 0;
		  }
		  for (int i = 0; i < n; ++i) {//初始化第0列：a[0..i]与b[0..0]的maxlcs
		    if (a[i] == b[0]) maxlcs[i][0] = 1;
		    else if (i != 0) maxlcs[i][0] = maxlcs[i-1][0];
		    else maxlcs[i][0] = 0;
		  }
		  for (int i = 1; i < n; ++i) { // 填表
		    for (int j = 1; j < m; ++j) {
		      if (a[i] == b[j]) maxlcs[i][j] = max(
		          maxlcs[i-1][j], maxlcs[i][j-1], maxlcs[i-1][j-1]+1);
		      else maxlcs[i][j] = max(
		          maxlcs[i-1][j], maxlcs[i][j-1], maxlcs[i-1][j-1]);
		    }
		  }
		  return maxlcs[n-1][m-1];
		}
		
		private int max(int x, int y, int z) {
		  int maxv = Integer.MIN_VALUE;
		  if (x > maxv) maxv = x;
		  if (y > maxv) maxv = y;
		  if (z > maxv) maxv = z;
		  return maxv;
		}
		```

	- 



