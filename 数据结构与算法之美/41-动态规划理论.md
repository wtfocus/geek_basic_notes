[toc]

## 41 | 动态规划理论：一篇文章带你彻底搞懂最优子结构、无后效性和重复子问题

1. 开篇题
	1. 什么样的问题可以用动态规划解决？
	2. 动态规划问题的思考过程是什么样的？
	3. 贪心、分治、回溯、动态规划这四种算法思想的区别和联系？

### “一个模型三个特征”　理论讲解 

1. **一个模型**：**多阶段决策最优解模型**
  - 我们一般是用动态规划来解决最优问题。
  - 解决问题的过程，需要经历多个决策阶段。
  - 每个决策阶段都对应着一组状态。然后我们寻找一组决策序列，经过这组决策序列，能够产生最终期望求解的最优值。

2. **最优子结构**
  - 问题的最优解包含子问题的最优解
  - 我们可以通过子问题的最优解，推导出问题的最优解
  - 对应到动态规划问题模型上，可以理解为，后面阶段的状态可以通过前面阶段的状态推导出来。
  
3. **无后效性**
	- 第一层含义是，在推导后面阶段的状态的时候，我们只关心前面阶段的状态值，不关心这个状态是怎么一步一步推导出来的。
	- 第二层含义是，某阶段状态一旦确定，就不受之后阶段的决策影响。
	
4.　**重复子问题**
- 不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态。

### “一个模型三个特征” 实例剖析

### 两种解题思路总结

1. **状态转移表法**

	1. 二维状态表

		- ![img](imgs/b3f0de1c81533a0d24c43426eaf09aca.jpg)
		- ![img](imgs/05a48baf7fb4d251bf5078840079107d.jpg)

	2. 代码实现

		- ```java
			
			public int minDistDP(int[][] matrix, int n) {
			  int[][] states = new int[n][n];
			  int sum = 0;
			  for (int j = 0; j < n; ++j) { // 初始化states的第一行数据
			    sum += matrix[0][j];
			    states[0][j] = sum;
			  }
			  sum = 0;
			  for (int i = 0; i < n; ++i) { // 初始化states的第一列数据
			    sum += matrix[i][0];
			    states[i][0] = sum;
			  }
			  for (int i = 1; i < n; ++i) {
			    for (int j = 1; j < n; ++j) {
			      states[i][j] = 
			            matrix[i][j] + Math.min(states[i][j-1], states[i-1][j]);
			    }
			  }
			  return states[n-1][n-1];
			}
			```

		- 

2. **状态转移方程法**

	1. 状态转移方程

		- ```
			
			min_dist(i, j) = w[i][j] + min(min_dist(i, j-1), min_dist(i-1, j))
			```

	2. 代码实现（递归加“备忘录”的方式）

		- ```java
			
			private int[][] matrix = 
			         {{1，3，5，9}, {2，1，3，4}，{5，2，6，7}，{6，8，4，3}};
			private int n = 4;
			private int[][] mem = new int[4][4];
			public int minDist(int i, int j) { // 调用minDist(n-1, n-1);
			  if (i == 0 && j == 0) return matrix[0][0];
			  if (mem[i][j] > 0) return mem[i][j];
			  int minLeft = Integer.MAX_VALUE;
			  if (j-1 >= 0) {
			    minLeft = minDist(i, j-1);
			  }
			  int minUp = Integer.MAX_VALUE;
			  if (i-1 >= 0) {
			    minUp = minDist(i-1, j);
			  }
			  
			  int currMinDist = matrix[i][j] + Math.min(minLeft, minUp);
			  mem[i][j] = currMinDist;
			  return currMinDist;
			}
			```

### 四种算法思想比较分析

1. 分类

	1. 贪心、回溯、动态规划

		> 这三个算法解决问题的模型，都可以抽象成我们今天讲的那个多阶段决策最优解模型

	2. 分治

		> 分治算法解决的问题尽管大部分也是最优解问题，但是，大部分都不能抽象成多阶段决策模型。

2. 动态规划 vs 回溯算法

	1. 回溯算法

		> 时间复杂度非常高，是指数级别的，只能用来解决小规模数据的问题

	2. 动态规划

		> 需要满足三个特征，最优子结构、无后效性和重复子问题

3. 动态规划 vs 分治算法

	1. 分治算法

		> 分治算法要求分割成的子问题，不能有重复子问题

	2. 动态规划

		> 动态规划之所以高效，就是因为回溯算法实现中存在大量的重复子问题。

4. 贪心算法

	1. 解决的问题需要满足三个条件，最优子结构、无后效性和贪心选择性

		> “贪心选择性”的意思是，通过局部最优的选择，能产生全局的最优选择