[TOC]

## 51 | 并行算法：如何利用并行处理提高算法的执行效率？

1. 开篇题
	- 当算法无法再继续优化的情况下，我们该如何借助**并行计算的处理思想**对算法进行改造？

### 并行排序

1. 对**归并排序**并行化处理

    - 将 8GB 的数据划分成 16 个小的数据集合，每个集合 500MB 数据。
    - 我们用 16 个线程，并行地对这 16 个 500MB 的数据集合进行排序。
    - 这 16 个小集合分别排序完成后，再将 16 个有序集合**合并**。

2. 对**快速排序**并行化处理

    - 先扫描一遍数据，找到数据所处的范围区间。
    - 把这个区间**从小到大**划分成 16 个小区间。
    - 针对 16 个小区间的数据，我们启动 16 个线程，并行地进行排序。
    - 等到 16 个线程都执行结束后，得到的数据就是有序数据了。

3. 小结

    - 相同点
        - 都是利用**分治思想**，对数据进行分片，然后并行处理。
    - 区别
        - 第一种处理思路是，先随意地对数据分片，排序后再合并。
        - 第二种处理思路是，先对数据按大小划分区间，然后再排序，排完序就不需要再处理了。

### 并行查找

1. **散列表**是一种非常适合快速查找的数据结构。

2. 空间

	- 针对散列表的**动态扩容**

		> 我们可以将数据分割成 k 份（如 16），每份中的数据只有原来的 1/k，然后我们针对这 k 个数据集合分别构建散列表。
		>
		> 当某个小散列表的装载因子过大的时候，我们可以单独对这个小散列表进行扩容，而其他散列表不需要扩容。

3. 时间

	- 当**查找**某个数据时，我们只需要通过 16 个线程，并行地在这个 16 个散列表中查找数据。这样的查找性能，比起一个大散列表的做法，并不会下降，反倒可能提高。
	- 当添加数据的时，我们可以选择将这个新的数据放入**装载因子最小**的那个散列表中，这样也有助于**减少散列冲突**。

### 总结

1. 并行处理思路，就是对数据进行**分片**，对没有依赖关系的任务**并行地执行**。