[TOC]

## 28 | 堆和堆排序：为什么说堆排序没有快速排序快？

1.  开篇题

	- 在实际开发中，快速排序的性能要比堆排序好，这是为什么呢？

### 理解“堆”

1. 堆是一种特殊的树。
2. 要求：
    - 堆必须是一个**完全二叉树**。
    - **堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值**。

3.  分类：

    - **大顶堆**
        - 对于每个节点的值都**大于等于**子树中每个节点的值的堆。
    - **小顶堆**
        - 对于每个节点的值都**小于等于**子树中每个节点的值的堆。

### 实现“堆”

1.  用**数组**来存储堆，如下图

	- ![img](imgs/4d349f57947df6590a2dd1364c3b0b1e-6476170.jpg)
	
	- 下标为 i 的节点
	    - **左子节点**，就是下标为`i*2` 的节点
	    - **右子节点**，就是下标为 `i*2+1`的节点
	    - **父节点**，就是下标为 `i/2` 的节点
2.  **堆化（heapify）**
	- 对一个完全二叉树进行调整，让其满足堆的特性。
3.  堆化方法
	- **从下往上**
	- **从上往下**

#### 堆中插入

1.  我们把新插入的元素放到堆的最后

	- ![img](imgs/e578654f930002a140ebcf72b11eb722-6476548.jpg)

2.  堆化

	- 顺着节点所在的路径，向上或者向下，对比，然后交换。这里是**从下往上**。
	- ![img](imgs/e3744661e038e4ae570316bc862b2c0e-6476588.jpg)

3.  代码实现

	- ```java
		public class Heap {
		  private int[] a; // 数组，从下标1开始存储数据
		  private int n;  // 堆可以存储的最大数据个数
		  private int count; // 堆中已经存储的数据个数
		
		  public Heap(int capacity) {
		    a = new int[capacity + 1];
		    n = capacity;
		    count = 0;
		  }
		
		  public void insert(int data) {
		    if (count >= n) return; // 堆满了
		    ++count;
		    a[count] = data;
		    int i = count;
		    while (i/2 > 0 && a[i] > a[i/2]) { // 自下往上堆化
		      swap(a, i, i/2); // swap()函数作用：交换下标为i和i/2的两个元素
		      i = i/2;
		    }
		  }
		 }
		```


#### 删除堆顶元素

1.  根据堆的定义的第二条中，“任何节点的值都大于等于（或小于等于）子树节点的值”。我们可以发现，**堆顶**元素存储的就是堆中数据的**最大值**或者**最小值**。
2.  删除

	- 删除堆顶元素，我们**把最后一个节点放到堆顶**。
3.  堆化（**从上往下**）

	- 利用父子节点对比方法。
	- 对于不满足父子节点大小关系的，互换两个节点，并且重复进行这个过程，直到父子节点之间满足大小关系为止。
4.  分解图

	- ![img](imgs/110d6f442e718f86d2a1d16095513260-6477080.jpg)

5.  代码实现

	- ```java
		public void removeMax() {
		  if (count == 0) return -1; // 堆中没有数据
		  a[1] = a[count];
		  --count;
		  heapify(a, count, 1);
		}
		
		private void heapify(int[] a, int n, int i) { // 自上往下堆化
		  while (true) {
		    int maxPos = i;
		    if (i*2 <= n && a[i] < a[i*2]) maxPos = i*2;
		    if (i*2+1 <= n && a[maxPos] < a[i*2+1]) maxPos = i*2+1;
		    if (maxPos == i) break;
		    swap(a, i, maxPos);
		    i = maxPos;
		  }
		}
		```
	
	- 

#### 时间复杂度分析

1. 一个包含 n 个节点的**完全二叉树**，树的高度不会超过 log<sub>2</sub>n。
2. **堆化**的过程是顺着节点所在路径比较交换的，所以，堆化的时间复杂度跟**树的高度**成正比，也就是 O(logn)。
3. 插入数据和删除堆项元素的主要逻辑就是**堆化**，所以，往堆中**插入**一个元素和**删除**堆顶元素的时间复杂度都是 O(logn)。

### 堆排序

1.  过程

	- **建堆**
	- **排序**

#### 建堆

1.  两种思路

    1.  **从前往后**处理数组数据，并且每个数据都是**从下往上**堆化。（同，插入思路）
    2.  **从后往前**处理数组数据，并且每个数据都是**从上往下**堆化。

2.  第二种实现思路分解图

	- ![img](imgs/50c1e6bc6fe68378d0a66bdccfff441e-6477840.jpg)
	- ![img](imgs/aabb8d15b1b92d5e040895589c60419d.jpg)

3.  代码实现

	- ```java
		
		private static void buildHeap(int[] a, int n) {
		  for (int i = n/2; i >= 1; --i) {
		    heapify(a, n, i);
		  }
		}
		
		private static void heapify(int[] a, int n, int i) {
		  while (true) {
		    int maxPos = i;
		    if (i*2 <= n && a[i] < a[i*2]) maxPos = i*2;
		    if (i*2+1 <= n && a[maxPos] < a[i*2+1]) maxPos = i*2+1;
		    if (maxPos == i) break;
		    swap(a, i, maxPos);
		    i = maxPos;
		  }
		}
		```
	
4.  时间复杂度分析

    -   堆排序的**建堆**过程的时间复杂度是 O(n)。
    -   每个节点堆化的过程中，需要比较和交换的节点个数，**跟这个节点的高度 k 成正比**。
    -   我们只需要将每个节点的**高度求和**，得出的就是建堆的时间复杂度。
        -   ![img](https://static001.geekbang.org/resource/image/89/d5/899b9f1b40302c9bd5a7f77f042542d5.jpg)
    -   将每个非叶子节点的高度求和，就是下面这个公式
        -   ![img](https://static001.geekbang.org/resource/image/f7/09/f712f8a7baade44c39edde839cefcc09.jpg)
    -   如上公式求解
        -   ![img](https://static001.geekbang.org/resource/image/62/df/629328315decd96e349d8cb3940636df.jpg)
    -   通过“等比数列”的求和公式来计算，最终结果就是下面这样：
        -   ![img](https://static001.geekbang.org/resource/image/46/36/46ca25edc69b556b967d2c62388b7436.jpg)
    -   因，h = log<sub>2</sub>n，代入公式 S，就能得到 S = O(n)。
    -   所以，建堆的时间复杂度就是 O(n)。

#### 2. 排序

1.  实现思路

    -   建堆结束后，数组中的数据已经是按照大顶堆的特性来组织的。数组中的第一个元素就是堆顶，也就是最大的元素。
    -   我们把**它跟最后一个元素交换**，那最大元素就放到了下标为 n 的位置（数组末尾）。
2.  实现过程
    -   这个过程有点类似上面的“删除堆顶元素”的操作，当堆顶元素移除之后，我们把下标为 n 的元素放到堆顶。
    -   然后再通过堆化，将 n - 1 个元素堆化。
    -   堆化完成后，我们再取堆顶的元素，放到下标是 n-1 的位置。
    -   一直重复这个过程，直到最后堆中只剩下标为 1 的一个元素，排序工作就完成了。
    
    -   ![img](imgs/23958f889ca48dbb8373f521708408d1-6520411.jpg)

2.  代码实现

    -   ```java
        // n 表示数据的个数，数组 a 中的数据从下标 1 到 n 的位置。
        public static void sort(int[] a, int n) {
          buildHeap(a, n);
          int k = n;
          while (k > 1) {
            swap(a, 1, k);
            --k;
            heapify(a, k, 1);
          }
        }
        ```

4.  小结

    -   **堆排序是原地排序算法。**
    -   堆排序包括**建堆**和**排序**两个操作，建堆过程的时间复杂度是 O(n)，排序过程的时间复杂度是 O(nlogn)，所以，堆排序整体的**时间复杂度**是 O(nlogn)。
    -   堆排序**不是稳定的排序算法**

### 解答开篇

1.  开篇题：为什么快速排序要比堆排序性能好？
    1.  堆排序数据**访问的方式**没有快速排序，对 CPU 缓存友好。
        -   对于快速排序来说，数据是顺序访问的。
        -   而对于堆排序来说，数据是跳着访问的。
    2.  对于同样的数据，在排序过程中，堆排序算法的**数据交换**要多于快速排序。
        -   **快速排序**的数据交换次数不会比逆序度多。
        -   **堆排序**的第一步是建堆，建堆的过程是打乱数据原有的相对先后顺序。导致原数据的有序度降低。

### 小结

-   今天，我们讲了堆这种数据结构。
-   **堆是一种完全二叉树。**
-   它最大的特性是：**每个节点的值都大于等于（或小于等于）其子树节点的值。**
    -   因此，堆被分成了两类，
        -   **大顶堆**
        -   **小顶堆**
-   堆中比较重要的两个操作是**插入**一个数据和**删除**堆顶元素。这两个操作都需要堆化。
    -   插入一个数据时候，
        -   我们把新插入的数据放到数组的最后，然后，**从下往上**堆化。
    -   删除堆顶数据的时候
        -   我们把数组中最后一个元素放到堆顶，然后，**从上往下**堆化。
    -   时间复杂度
        -   **O(logn)**
-   堆排序
    -   堆排序包含两个过程
        -   建堆
        -   排序

### 课后思考

1.  在讲堆排序建堆的时候，我说到，对于完全二叉树来说，下标从 n/2 + 1 到 n 的都是叶子节点，这个结论是怎么推导出来的呢？
2.  关于堆，你还能想到它的其他应用吗？

### 精选留言

1.  WhoAmWe

    >   应用:
    >
    >   1.topK
    >
    >   2.流里面的中值
    >
    >   3.流里面的中位数
    >
    >   



